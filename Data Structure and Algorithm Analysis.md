# 第一章：绪论

## 1.1数据结构的基本概念

### 基本概念和术语

* 数据：数据是信息的载体，是描述客观事物的属性的数，字符及所有能输入到计算机程序和处理的符号集合。

* 数据元素：数据元素是数据的基本单位，通常作为一个整体考虑和处理。

* 数据对象：数据对象是具有相同性质的数据元素的集合，是数据的一个子集。

* 数据类型：数据类型是一个值的集合和定义在此集合上的一组操作总称。分为：原子结构（其值不可再分的数据类型），结构类型（其值可以再分解为若干成分的数据类型），抽象数据类型（抽象数据类型及与之相关的操作）。

* 数据结构：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。包括三方面：逻辑结构，存储结构，数据的运算。

### 数据结构的三要素

#### 1.数据的逻辑结构

* 概述：逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据，和数据的存储无关，是独立于计算机的。

* 分类
  
  - 线性结构：线性表，栈，队列，数组。
  
  - 非线性结构：集合，树，图。
  
  - 抑或（另外的一种分类，和上面不一样）：集合，线性，层次，网状

#### 2.数据的存储结构

* 概述：存储结构是指数据结构在计算机中的表示（又被称为映像），又称物理结构，是用计算机语言实现的逻辑结构，它依赖于计算机语言。

* 分类：
  
  - 顺序存储：把逻辑上相邻的元素存储在物理上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。优点是可以实现随机存取，每个元素占用最少的存储空间。缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。
  
  - 链式存储：要求逻辑上相邻的元素在物理上也相邻，借助指示元素存储的指针来表示元素之间的逻辑关系。优点是不会出现碎片现象，能充分利用所有的存储单元。缺点是每个元素因为存储指针而占用额外的存储空间，且只能实现顺序存取。
  
  - 索引存储：在存储元素信息的同时，还建立附加的索引表。优点是检索速度快。缺点是附加的索引表额外占用空间，增加和删除数据时也要修改索引表，会花费较多的时间。
  
  - 散列（哈希）存储：根据元素的关键字直接计算出该元素的存储地址。优点是检索，增加，删除元素的操作都很快。缺点是若散列函数不好，则可能造成散列冲突，而解决冲突会增加时间和空间开销。

#### 3.数据的运算

* 概述：施加在数据上的运算包括运算的定义和实现。
  
  - 运算的定义：针对逻辑结构，指出运算的功能。
  
  - 运算的实现：针对存储结构，指出运算的具体操作步骤。

## 1.2算法和算法评价

### 算法的基本概念

* 概述：算法是对特定问题求解步骤的一种描述，它是指令的有限序列    ，其中的指令表示一个或者多个操作。

* 重要特性：
  
  - 有穷性：一个算法必须执行有穷步后结束，且每一步都在有穷时间内完成。
  
  - 确定性：算法中每个指令必须有确切的含义，且对于相同的输入只能得到相同的输出。
  
  - 可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
  
  - 输入与输出：有零个或者多个输入，有一个或者多个输出。

* 优秀算法的标准：
  
  - 可读性：具有良好的可读性，帮助人们理解。
  
  - 正确性：可以正确的解决问题。
  
  - 健壮性：输入非法数据时，算法能够适当的做出反应和处理，而不会产生莫名其妙的输出结果。
  
  - 效率和低存储量的需求：执行时间快，所需空间小。

### 算法效率的度量

- 概述：通过时间复杂度和空间复杂度来描述的。

- 时间复杂度：

- 空间复杂度：

- 计算规则：
  
  - 加法规则：O(f(n))+O(g(n))=O(max(f(n),g(n)))
  
  - 乘法规则：O(f(n))*O(g(n))=O(f(n)*g(n))

# 第二章：线性表

## 2.1线性表的定义和基本操作

### 线性表的定义

* 概述：线性表是具有相同数据元素的有限序列，其中n为表长。

* 线性表的特点
  
  - 表中元素个数有限。
  
  - 表中元素具有逻辑上的顺序性，表中元素有其先后次序。
  
  - 表中元素都是数据元素，每个元素都是单个元素。
  
  - 每个元素占有相同的存储空间。

* 注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系，顺序表和链表是指存储结构。

### 线性表的基本操作

* InitLIst(&L):初始化列表，构造一个空列表。

* Length(L):求表长，返回L中元素的个数。

* LocateElem(L,e):按值查找操作，在L中查找具有给定关键字的元素。

* GetElem(L,i):按位查找操作，获取L中第i位的元素的值。

* ListInsert(&L,i,e):插入操作，在表L中第i位上插入指定元素。

* ListDelete(&L,i,&e):删除操作，删除L中第i位的元素，并用e返回删除元素的值。

* PrintList(L):输出操作，按照顺序输出L中的所有元素。

* Empty(L):判空操作。

* DestoryList(&L):销毁操作，销毁线性表，并释放L所占用的空间。

## 2.2线性表的顺序表示

### 顺序表的定义

* 概述：用一组地址连续的存储单元依次存储线性表中的元素。

* 一维数组的空间分配：
  
  - 静态分配：数组的大小和空间已经固定，一旦空间占满，再加入新的元素将会溢出。
  
  - 动态分配：通过动态存储分配语句分配空间，一旦空间占满，就开辟一块更大的空间，来替换原来的空间。

* 注意：动态分配仍然是顺序存储结构，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时决定。

* 特点：
  
  - 随机访问：通过首地址和元素序号可以在O（1）内找到指定元素。
  
  - 存储密度高：每个结点只存储数据元素。
  
  - 执行插入和删除操作时，需要大量移动元素。

### 顺序表上基本操作的实现

* 插入操作：由于顺序表的元素的物理位置也是相邻的，所以当插入新元素时就要对表中的元素进行整体移动。    
  
  - 最好情况：在表尾插入，元素后移语句不执行，O（1）。
  
  - 最坏情况：在表头插入，元素后移语句执行n次，O（n）。
  
  - 平均情况：O（n/2）=O（n）。

* 删除操作：即为移动元素，对想要删除的元素进行覆盖。
  
  - 最好情况：在表尾删除，不需要移动元素，O（1）。
  
  - 最坏情况：在表头删除，需要一定除第一个外的所有元素，O（n）。
  
  - 平均情况：O（n）。

* 按值查找操作：在L中查找具有给定关键字的元素。
  
  - 最好情况：查找的元素在表头，只要比较一次，O（1）。
  
  - 最坏情况：要查找的元素在表尾（或者不存在），需要比较n次，O（n）。
  
  - 平均情况：O（n）。

## 2.3线性表的链式表示

### 实现方式

* 带头结点：空链表的判断：L==NULL。代码书写不方便。

* 不带头结点：空链表的判断：L->next==NULL。写代码方便。

### 单链表的定义

* 概述：通过一组任意存储单元来存储线性表中的元素，对每个链表结点，除了存放元素自身外，还需要存放一个指向后继的的指针。

* 结构：
  
  - data:数据域，存放数据元素。
  
  - next:指针域，存放其后继结点的位置。

* 优点：解决顺序表需要大量连续存储单元的缺点。

* 缺点：附加指针域，浪费存储空间。查找特定结点时，需要从头遍历。

### 单链表的基本操作实现

* 利用头插法建立单链表：从空表开始，生成新结点，并将读取到的数据存放在新结点的数据域中，然后新结点插入到当前链表的表头，即头节点之后。
  
  - 优点：算法实现简单。、
  
  - 缺点：生成的链表中结点次序和输入数据顺序不一致，可以利用这个特点进行链表倒置。

* 利用尾插法：将新结点插入到当前链表的表尾，为此必须增加一个尾指针r，使其永远指向当前链表的尾结点。

* 按序号查找结点值：O（n）

* 按值查找表结点：O（n）

* 插入节点：
  
  ```c
  p=GetElem(L,i-1);
  s->next=p->next;
  p->next=s;
  ```
  
  - 若在给定结点下插入，则时间复杂度位O（1）
  
  - 本操作的主要时间开销在于查找第i-1个元素，时间复杂度为O（n）

* 删除操作：先检查删除位置的合理性，查找表中第i-1个结点，即被删除节点的前驱节点。
  
  - 方法一：先从表头顺序查找前驱节点，然后删除。O（n）
  
  - 方法二：删除该结点的后继结点，就是把后继结点的值赋予自身，然后删除后继结点。O（1）

* 求表长操作：遍历链表，设置一个计数器，每访问一个结点就++。O（n）

### 双链表

* 概述：双链表中有两个指针prior和next，分别指向前驱结点和后继结点

* 插入和删除操作：原则是进行操作时要考虑是否会造成断链。

### 循环链表

* 循环单链表：最后一个结点的指针不是NULL，而改为指向头结点，形成一个环。
  
  - 判空条件：头结点的指针是否等于L。

* 循环双链表：头结点的prior指向尾结点，尾结点的next指向头结点。当表为空时，头结点的prior和next都等于L。

* 静态链表
  
  -     基本结构：借助数组来描述线性表，预先分配一块的内存空间，结点也有data和next，这里的指针是结点的相对位置（数组下标），又称游标。
  
  - 特点：静态链表以next==-1来作为结束的标志。
  
  - 优点：增删操作不需要移动大量元素。
  
  - 缺点：不能随机存取，只能从头结点开始依次往后查找，容量不可变。
  
  - 适用场景：不支持指针的低级语言，数据元素数量固定不变。

## 2.4顺序表和链式表的比较

* 存取（读写）方式：
  
  - 顺序表可以顺序存取，也可以随机存取。
  
  - 链表只能从表头顺序存取元素。

* 逻辑和物理结构：
  
  - 顺序存储：逻辑上相邻的元素，对应的物理存储位置也相邻。
  
  - 链式存储：逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系通过指针链接来表示。

* 查找，插入，删除操作：
  
  |     | 按值查找                | 按序号查找 | 插入，删除操作 |
  | --- | ------------------- | ----- | ------- |
  | 顺序表 | 有序时：O（logn）无序时：O（n） | O（1）  | O（n）    |
  | 链表  | O（n）                | O（n）  | O（n）    |

* 空间分配：
  
  - 链式存储：空间分配灵活。
  
  - 顺序存储：
    
    - 静态分配：存储空间存满就无法进行扩充，内存会溢出。
    
    - 动态分配：对空间进行扩充要进行数据移动，效率低下。

## 2.5选择合适的存储结构

* 基于存储考虑：
  
  - 难以估计线性表的长度或存储规模，不宜采用顺序表。
  
  - 链表不用事先估计存储规模，但链表的存储密度低。

* 基于运算考虑：
  
  - 按序号访问元素，顺序表优于链式表。
  
  - 进行插入，删除操作，链式表优于顺序表。

* 基于环境考虑：
  
  - 顺序表基于数组，更容易实现。
  
  - 链表基于指针，更复杂一些。

## 2.6 Code

### 顺序表

```cpp
// 静态分配空间

#define MAXSIZE 10
Typedef struct {
    ElemType data[MAXSIZE];        //静态数组存放的数据元素
    int length;                    //顺序表的当前长度
}SqList;                        //顺序表的类型定义


Status Initlist(SqList &L){
    L.length=0;//顺序表的初始长度为0
    return ;
}
```

```cpp
//动态分配

#define InitSize 10
typedef struct{
    ElemType *data;        
    int MaxSize;        
    int length;            
}SqList;


Status InitList(SqList &L){
    L.data=new ElemType[MAXSIZE];    //为顺序表分配一个大小为MAXSIZE的数组空间
    if(!L.data) return ERROR;        //存储空间分配失败退出
    L.length=0;                        //空表长度为0
    return OK;
}
```

```cpp
//取值

Status GetElem(SqList L,int i,ElemType &e){
    if(i<1||i>L.length)    return ERROR;    //判断i值是否合理
    e=L.data[i-1];                        //data[i-1]存储第i个数据元素
    return OK;

}
```

```cpp
//查找

int LocateElem(SqList L,ElemType e){
//在顺序表L中查找值为e的数据元素，返回其序号
    for(int i=0;i<L.length;i++)
        if(L.data[i]==e)    return i+1;
    return 0;

}
```

```cpp
//插入

Status ListInsert(SqList &L,int i,ElemType e){
    if(i<1||i>L.length+1) return ERROR;
    if(L.length==MAXSIZE)    return ERROR;
    for(int j=L.length;j>=i;j--)
        L.data[j]=L.data[j-1];
    L.data[i-1]=e;
    L.length++;
    return OK;
}
```

```cpp
//删除

Status ListDelete(SqList &L,int i){
    if(i<1||i>L.length) return ERROR;
    for(int j=i;j<L.length;j++)
        L.data[j-1]=L.data[j];
    //int e=L.data[i-1];
    L.length--;
    return OK;
}
```

### 单链表

```cpp
//定义

typedef struct LNode{    //定义单链表结点类型
    ElemType data;        //数据域
    struct LNode *next;    //指针域
}LNode,*LinkList;        
```

```cpp
//创建单链表之前插法

void CreateList_H(LinkList &L,int n){
    L=new LNode;    
    L->next=NULL;            //先建立一个带头结点的空链表
    for(int i=0;i<n;i++){    
        p=new LNode;    //生成新节点*p
        cin>>p->data;    //输入元素值赋给新节点*p的数据域
        p->next=L->next;    //将新节点*p插入到头结点之后
        L->next=p;
    }


}
```

```cpp
//创建单链表之后插法

void CreateList_R(LinkList &L,int n){
//正位序输入n个元素的值，建立带表头节点的单链表L
    LNode *p,*r;        //先建立一个带头结点的空链表
    L=new LNode;
    L->next=NULL;
    r=L;                //尾指针r指向头结点
    for(int i=0;i<n;i++){
        p=new LNode;    //生成新节点
        cin>>p->data;    //输入元素值赋给新节点*p的数据域
        p->next=NULL;
        r->next=p;        //将新节点*p插入尾节点*r之后
        r=p;            //r指向新的尾节点*p
    }
}
```

```cpp
//初始化

//带头结点
Status InitList(LinkList &L){
    L=new LNode;        //生成新节点作为头结点，用头指针L指向头结点
    L->next==NULL;        //头结点的指针域置空
    return OK;
}
//不带头结点
Status InitList(LinkList &L){    
    L=new LNode;        
    L==NULL;        
    return OK;
}
```

```cpp
//取值

Status GetElem(LinkList &L,int i,ElemType &e){
//在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值
    LNode *p=L->next;    //初始化，p指向首元结点，计数器j初值赋为1
    int j=1;            //顺链域往后查找，直到p为空域或p指向第i个元素
    while(p&&j<i){        //p指向下一个结点
    p=p->next;            //计算机j相应加1
    j++;    
    }
    if(!p||j>i)    return ERROR;        //i值不合法i>n或i<=0
    e=p->data;                    //取第i个结点的数据域
    return OK;
}
```

```cpp
//查找

LNode *LocateElem(LinkList L,ElemType e){
//在带头结点的单链表L中查找值为e的元素
    LNode *p;    //初始化
    p=L->next;    //p指向首元节点
    while(p&&p->data!=e){
        p=p->next;
        }
    return p;        //返回值为e的节点地址p
```

```cpp
//插入

Status ListInsert(LinkList &L,int i,ElemType e){
    //在带头结点的单链表L中第i个位置插入值为e的元素
    LNode *p=L,*s;            
    int j=0;
    while(p&&(j<i-1)){
    p=p->next;j++;}                //查找第i-1个节点，p指向该节点
    if(!p||j>i-1)    return ERROR;        //i>n+1或i<1
    s=new LNode;                //生产新节点s
    s->data=e;                    //将节点*s的数据域置为e
    s->next=p->next;            //将节点*s的指针域指向节点ai
    p->next=s;                    //将节点*p的指针域指向节点*s
    return OK;
```

```cpp
//删除

Status LiseDelete(LinkList &L,int i){
//在带头结点的单链表L中，删除第i个元素
    LNode *p=L,*q;
    int j=0;
    while((p->next)&&(j<i-1))    //查找第i-1个节点，p指向该节点
    {
        p=p->next;
        j++;
    }
    if(!(p->next)||(j>i-1))    return ERROR;        //当i>n或i<1 删除位置不合理
    q=p->next;                            //临时保存被删节点的地址以备释放
    p->next=q->next;                    //改变删除节点前驱结点的指针域
    delete q;                            //释放删除节点的空间
    return OK;
}
```

## 双链表

```cpp
//定义

typedef struct DuLNode{
    ElemType data;                //数据域
    struct DuLNode *prior;        //指向直接前驱
    struct DuLNode *next;        //指向直接后继
}DuLNode,*DuLinkList;
```

```cpp
//插入

Status ListInsert(LinkList &L,int i,ElemType e){
    LNode *p;
    if(!(p=GetElem_DuL(L,i)))    //在L中确定第i个元素的位置指针p
        return ERROR;
    s=new DuLNode;        //生成新节点*s
    s->data=e;                
    s->prior=p->prior;        
    p->prior->next=s;
    s->next=p;
    p->prior=s;
    return OK;

}
```

```cpp
//删除

Status ListDelete(LinkList &L,int i){
    LNode *p;
    if(!(p=GetElem_DuL(L,i)))    //在L中确定第i个元素的位置指针p
        return ERROR;
    p->prior->next=p->next;
    p->next->prior=p->prior;
    delete p;                    //释放被删除节点的空间
    return OK;

}
```

# 第三章 栈和队列

## 3.1 栈

* 栈的基本概念：只允许在一端进行插入或者删除的线性表，先进后出。
  
  - 卡特兰数：n个不同元素进栈，出栈元素不同排列的个数    C（n/2n）/（n+1）
  
  - 栈的基本操作：
    
    - Initstack(&S):初始化一个空栈。
    
    - StackEmpty(S):判断栈是否为空。
    
    - Pop(&S,&x):若栈非空，则弹出栈顶元素。
    
    - GetTop(&S,&x):读取栈顶元素。
    
    - Destorystack(&S):销毁栈。
  
  - 结构
    
    * 栈顶（Top）：线性表允许插入和删除的那一端。
    
    * 栈底（Bottom）：固定的，不允许插入和删除的那一端。

* 栈的顺序存储结构
  
  - 顺序栈的实现：采用顺序存储结构的的栈称为顺序栈，它利用一组连续的存储单元存放自栈底到栈顶的数据元素，同时附加一个指针指示当前栈顶元素的位置。
  
  - 共享栈：
    
    - 概念：让俩个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间中间延申。
    
    - 基本原则：两个栈的栈顶指针都指向栈顶元素，top0==-1，0号栈为空，top1==maxsize，1号栈为空。当两个栈顶指针相邻时，判断栈为满栈。
    
    - 存取数据的时间复杂度都是O（1）
- 栈的链式存储结构
  
  - 采用单链表实现，并规定所有操作都是在单链表的表头进行。
  
  - 优点：便于多个栈共享空间和提高效率，且不存在栈满上溢的问题。

## 3.2 队列

- 队列的基本概念：一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除，先进先出
  
  - 基本操作：和栈相似，省略，参照上面。
  
  - 结构：
    
    - 队头（Front）：允许删除的一端。
    
    - 队尾（Rear）：运行插入的一端。

- 队列的顺序存储结构
  
  - 顺序队列的实现：分配一块连续的存储空间来存放队列的元素，并附加俩个指针。
  
  - 循环队列
    
    - 概念：把存储队列元素的表从逻辑上视为一个环。
    
    - 基本操作
      
      - 初始时：Q.front=Q.rear=0
      
      - 队首指针进1：Q.front=(Q.front+1)%MaxSize
      
      - 队尾指针进1：Q.rear=(Q.rear+1)%MaxSize
      
      - 队列长度：(Q.rear+MaxSize-Q.front)%MaxSize
    
    - 判断条件
      
      - 队空：Q.front==Q.rear
      
      - 队满：字太多了见pdf &gt;-&lt;

- 队列的链式存储结构
  
  - 同时带有队头和队尾指针的单链表，当Q.front=NULL 且 Q.rear==NULL,链式队列为空。
  
  - 优点：适合数据元素变动比较大的情形，不存在队列满且产生溢出的问题。

- 双端队列
  
  - 概述：允许两端都可以进行入队和出队的操作的队列，逻辑结构仍然是线性结构，将队列的两端分别为前端和后端。
  
  - 分类：
    
    - 输出受限的双端队列：允许在进行插入和删除，但在另一端只能插入的队列。
    
    - 输入受限的双端队列：允许在进行插入和删除，但在另一端只能删除的队列。

- 前缀，中缀，后缀表达式的计算：只适合个人心里领会，不方便写出来。

# 第四章 串

## 4.1串的定义和实现

- 基本概述
  
  - 串是由零个或多个字符组成的有限序列
  
  - 串中任意个连续的字符组成的子序列称为该串的子串，包含字串的串相应的称为主串
  
  - 字串在主串中的位置以字串的第一个字符在主串中的位置来表示
  
  - 由一个或者多个空格（空格是特殊字符）组成的串称为空格串，其长度为串中空格字符的个数

- 串的存储结构
  
  - 定长顺序存储表示
    
    - 类似线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列
    
    - 截断：串的实际长度只能小于等于MAX Size，超过预定长度的串值会被舍去
    
    - 串的表示方法：
      
      - 用一个额外的变量来存放串的长度
      
      - 串值后面加入一个不记长度的结束标记字符“/0”，此时串长为隐含值
  
  - 堆分配存储表示：和上面的差不多，但是它们的存储空间是在程序执行过程中动态分配的
  
  - 块链存储表示：每个结点既可以存放一个字符也可以存放多个字符，每个结点称为块，整个链表称为块链结构

- 串的基本操作
  
  - StrAssign(T,chars):赋值操作，把串T赋值为chars
  
  - StrCopy(&T,S):复制操作，由串S复制得到串T
  
  - StrEmpty(S):判空操作。
  
  - Strcompare(S,T):比较操作
  
  - StrLength(S):求串长
  
  - SubString(&Sub,S,pos,len):求字串，用Sub返回S第pos个字符起长度为len的字串
  
  - Concat(&T,S1,S2):串连接
  
  - Index(S,T):定位操作，若主串S中存在与串T相同的字串，则返回它在主串S中第一次出现的位置，否则函数值为0
  
  - clearString(&S):清空操作
  
  - DestoryString(&S):销毁串

- 字符集编码
  
  - 英文字符：ASCII编码
  
  - 中英文：Unicode字符集

## 4.2串的模式匹配

- 简单的模式匹配算法：简单来说就是暴力算法，最坏的时间复杂度是O（ nm）,平均情况下也是。    

- KMP算法：略，之前刷题写的已经很多，没兴趣再写了，就是最大公共前后缀数组的构建和使用。直接看代码吧。平均时间复杂度O（n+m），最坏的时间复杂度O（n*m）
  
  ```cpp
  #include<iostream>
  
  using namespace std;
  
  const int N=1e5+10,M=1e6+10;
  char s[M],p[N];
  int ne[N],n,m;
  
  int main()
  {
      cin>>n>>p+1>>m>>s+1;
      //构建ne数组的过程
      for(int i=2,j=0;i<=n;i++)
      {
          while(j&&p[i]!=p[j+1]) j=ne[j];
          if(p[i]==p[j+1]) j++;
          ne[i]=j;
      }
  
      //匹配的过程
      for(int i=1,j=0;i<=m;i++)
      {
          while(j&&s[i]!=p[j+1]) j=ne[j];
          if(s[i]==p[j+1]) j++;
          if(j==n) 
          {
              printf("%d ",i-j);
              j=ne[j];
          }
      }
      return 0;
  }
  
  作者：snowstorm
  链接：https://www.acwing.com/activity/content/code/content/5849324/
  来源：AcWing
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
  ```

# 第五章 二叉树

## 5.1树的基本概念

- 树的定义：树n（n>=0）个结点的有限集合，当n=0时，称为空树。
  
  - 在任意一棵非空树中，应该满足有且仅有一个特定的称为根的结点，其余结点可以分为m（m>0）个互不相交的有限集T1，T2....Tm，其中每个集合本身又是一颗树，并且称为根的子树。
  
  - 树是一种逻辑结构，也是一种分层结构，树的根结点没有前驱，除此之外的所有结点都有且仅有一个前驱，树中所有结点可以有零个或多个后继。

- 基本术语
  
  - 以k结点为例：
    
    - k的祖先：根到结点k的唯一路径上的任意点
    
    - 子孙：和祖先定义反过来
    
    - 双亲：根到结点k的唯一路径上最接近结点k的结点称为k双亲
    
    - 孩子：和双亲的定义反过来
    
    - 兄弟：有相同双亲的结点称为兄弟
  
  - 结点的度：树中一个结点的孩子个数（只能算直接相连的结点），树中结点的最大度数称为树的度。
  
  - 分支结点：度大于0的结点
  
  - 叶子结点（又称终端结点）：度为0的结点，即没有孩子的结点
  
  - 结点的层次：从树根开始定义，根结点为第一层，它的子结点为第二层，以此类
  
  - 结点的深度：从根结点开始自定向下逐层累加的
  
  - 结点的高度：从叶结点开始自底向上逐层累加的
  
  - 树的高度（深度）：树中结点的最大层数
  
  - 有序树和无序树：树中结点的各子树从左到右是有次序的，不能互换，此谓之有序树，否则为无序树
  
  - 路径和路径长度：树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成，而路径上所经过边的个数就是路径长度
  
  - 森林：n棵互不相交的树的集合，只要把树的根结点删去就成为森林，给n棵独立树加上一个结点，并把这n棵树作为该结点的子树，则森林就变成了树

- 树的性质
  
  - 树中的结点数等于所有结点的度数加1
  
  - 度为m的树中第i层上至多有 $m^{i-1}$  个结点（i>=1)
  
  - 高度为h的m叉树至少有h个结点
  
  - 高度为h的m叉树至多有 $(m^h-1) \over (m-1)$ 个结点
  
  - 高度为h，度为m的树至少有h+m-1个结点
  
  - 具有n个结点的m叉树的最小高度为  $log_m(n(m-1)+1)$ 

## 5.2二叉树的概念

- 二叉树的定义及其主要特性
  
  - 定义：二叉树是另一种树形结构，其特点是每个结点至多有两个子树，并且二叉树的子树有左右之分，其次序不能颠倒。
  
  - 二叉树和度为2的有序树的区别：
    
    - 度为2的树至少有三个结点，而二叉树可以为空
    
    - 度为2的有序树的孩子左右次序是相对于另一个孩子而言，若结点只有一个孩子，则无须区分左右次序，但是二叉树无论孩子数是否为2，均需要确定左右次序。
    
    - 特殊的二叉树
      
      - 满二叉树：高度为h，且含有 $2^h-1$ 个结点的二叉树
        
        - 对于编号为i的结点
          
          - 双亲为 i/2，（下取整）
          
          - 左孩子：2i
          
          - 右孩子：2i+1
      
      - 完全二叉树：高度为h，有n个结点的二叉树，当且仅当每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应。
        
        - 特点：
          
          - i<=n/2,则结点为分支结点，否则为叶结点
          
          - 叶子结点只可能出现在层次最大两层上，对于最大层次的叶子结点，都依次排列在该层最左边的位置
          
          - 若有度为1的结点，则只可能有一个，且只有左孩子没有右孩子（重要特征）
          
          - 按层序编号后，一旦出现某结点（编号为i）为叶子结点或者只有左孩子，则编号大于i的结点均为叶子结点
          
          - 若n为奇数，则每个分支结点都有左右孩子
          
          - 若n为偶数，则编号最大的分支结点（编号为n/2）只有左孩子，没有右孩子，其余分支结点左右孩子均有。
      
      - 二叉排序树：左子树上所有结点的关键字均小于根结点的关键字，右子树上所有结点的关键字均大于根结点的关键字，左右两棵子树有各是一颗二叉排序树
      
      - 平衡二叉树：任何结点的左右子树深度之差不超过1
  
  - 二叉树的性质：
    
    - 非空二叉树上第k层上至多 $2^{k-1}$ 个结点
    
    - 高度为h的二叉树至多有 $2^h-1$ 个结点
    
    - 结点i所在层次（深度）为 $log_2i+1$ 
    
    - 具有n（n>0)个结点的完全二叉树的高度为 $log_2(n+1)$ 或者 $log_2n+1$ （都是要下取整）

- 二叉树的存储结构
  
  - 顺序存储结构：用一组地址连续的存储单元依次自上而下，自左至右存储完全二叉树结点上的元素，即完全二叉树上编号为i的结点元素存储在一维数组下标为i-1的分量中，完全二叉树和满二叉树比较适合，一般的二叉树为了能反映二叉树中结点之间的逻辑关系，只能添加不存在的空结点，让其每个结点与完全二叉树上的结点相同，再存储到一维数组中。
  
  - 链式存储结构：
    
    ```cpp
    typedef char Elemtype;  // 数据类型
    
    /*二叉树的链式存储结构*/
    typedef struct BiTNode
    {
        Elemtype data; // 数据域
        struct BiTNode* lchild, * rchild; // 左右孩子指针
    }BiTNode, *BiTree;
    ```

## 5.3 二叉树的遍历和线索二叉树

- 二叉树的遍历：
  
  - ![](https://img-blog.csdnimg.cn/97c72517666e46448a3ceb29cc807c2a.png)
  
  - 个人总结（不一定正确&gt;_&lt;_）
    
    - 先序遍历最好理解，就是先访问到谁，就输出谁。
    
    - 中序遍历是先输出没有左孩子或者左孩子已经被访问输出的结点，再依次返回输出。
    
    - 后序遍历是先输出没有左右孩子或者左右孩子都被访问输出的结点，再依次返回输出。
  
  - ```cpp
    /*先序遍历*/
    void PreOrder(BiTree T)
    {
        if (T != NULL)
        { 
            visit(T);              // 访问结点              
            PreOrder(T->lchild);   // 遍历结点左子树
            PreOrder(T->rchild);   // 遍历结点右子树
        }
    }
    
    /*输出树结点*/
    void visit(BiTree T)
    {
        printf("树结点的值：%c\n", T->data);
    }
    ```
  
  - ```cpp
    /*中序遍历*/
    void InOrder(BiTree T)
    {
        if (T != NULL)
        {
            InOrder(T->lchild);    // 遍历结点左子树
            visit(T);              // 访问结点
            InOrder(T->rchild);    // 遍历结点右子树
        }
    }
    
    /*输出树结点*/
    void visit(BiTree T)
    {
        printf("树结点的值：%c\n", T->data);
    }
    ```
  
  - ```cpp
    /*后序遍历*/
    void PostOrder(BiTree T)
    {
        if (T != NULL)
        {
            PostOrder(T->lchild);    // 遍历结点左子树
            PostOrder(T->rchild);    // 遍历结点右子树
            visit(T);                // 访问结点
        }
    }
    
    /*输出树结点*/
    void visit(BiTree T)
    {
        printf("树结点的值：%c\n", T->data);
    }
    ```

- 层次遍历
  
  - 利用队列实现，先将二叉树根结点入队，然后出队，访问出队结点，若有左子树则左子树入队，若有右子树，则右子树入队，如此反复，直至队列为空
  
  - ![](https://img-blog.csdnimg.cn/42067db3ee904b5181cc3c66e4376fdb.png)
  
  - ![](https://img-blog.csdnimg.cn/871e2b5352174bceada3bca1c0b398be.gif)
  
  - ```cpp
    //二叉树的结点（链式存储）
    typedef struct BiTNode {
        char data;
        struct BiTNode* lchild, * rchild;
    }BiTNode,*BiTree;
    
    //链式队列结点
    typedef struct LinkNode {
        BiTNode* data;                  //存指针而不是结点，节省内存空间
        struct LinkNode* next;
    }LinkNode;
    
    typedef struct {
        LinkNode* front, * rear;        //队头队尾指针
    }LinkQueue;
    
    //层序遍历
    void LevelOrder(BiTree T)
    {
        LinkQueue Q;
        InitQueue(Q);                        //初始化辅助队列
        BiTree p;
        EnQueue(Q, T);                        //将根结点入队
        while (!IsEmpty(Q))                    //队列不空则循环
        {
            DeQueue(Q, p);                    //对头结点出队
            visit(p);                        //访问出队结点
            if (p->lchild != NULL)
                EnQueue(Q, p->lchild);        //左孩子入队
            if (p->rchild != NULL)
                EnQueue(Q, p->rchild);        //右孩子入队
        }
    }
    ```

- 由遍历序列构造二叉树
  
  - 若只给出一颗二叉树的先/中/后序遍历的一种，不能确定唯一的二叉树
  
  - 二叉树的先序遍历和中序遍历或者后序遍历和中序遍历可以唯一的确定一颗二叉树（总之就是中序遍历加上先序或者后序遍历的其中一个就可以）
  
  - 层序遍历加上中序遍历也可以确定一颗二叉树

- 线索二叉树
  
  - 基本概念：遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点（除第一个和最后一个）都有一个直接的前驱和后继。
  
  - 规定：若无左子树，令lchild指向前驱结点，若无右子树，令rchild指向后继结点。
  
  - ```cpp
    //二叉树结构体线索存储结构
    
    struct Tree
    {
        char name[28];        //需要存储的数据 
        int num;
        int L;        //左右的标志
        int R;        //0表示指示结点的左（右）孩子，1表示指示结点的前驱（后继）
        struct Tree *lchild,*rchild;    //左右孩子的指针
    };
    ```
  
  - ```cpp
    //中序遍历线索化
    
    struct Tree *pre = NULL;    //全局变量 
    
    void Inthreading(struct  Tree  *p)
    {
        Inthreading(p->lchild);    //递归左子树线索化
    
        if(!p->lchild)            //没有左孩子
        {
            p->L = 1;
            p->lchild = pre;    //本来指向左孩子的指针指向前驱结点 
        }
    
        if(!pre->rchild)        //没有右孩子
        {
            pre->R = 1;
            pre->rchild = p;    //本来指向右孩子的指针指向后继结点 
        }
    
        pre = p;    //保持pre指向p的前驱
    
        Inthreading(p->rchild);    //递归右子树线索化
    }
    ```
  
  - 线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历该二叉树的时候才能得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。
  
  - ![](https://img-blog.csdnimg.cn/2dc154db87a84b609d10c6a523fdae78.png)
  
  - ```cpp
    //遍历代码
    
    void print(struct Tree *T)
    {
        struct Tree *p;
        p = T->lchid;    //p指向根结点
    
        while(p!=T)    //当p是空树，或等于T时结束循环
        {
            while(p->L == 0)
                p = p->lchild;
               cout << name <<" " << num << endl;
            while(p->R == 1 && p->rchild != T)
            {
                p = p->rchild;    //访问后续结点
                cout << name <<" " << num << endl;
            }
            p = p->rchild;
        }
    }
    ```

## 5.4 树、森林

- 树的存储结构：
  
  - 双亲表示法：用一个一维数组存储每个结点，数组的下标就是结点的指针位置，每个结点包括一个数据与与指向父亲结点的数组下标的域。
  
  - 孩子表示法：用一个线性表来存储树的所有结点信息，称为结点表。每个结点建立一个孩子表，孩子表中只存储孩子结点的地址信息（可以是指针、数组下标或者内存地址）。
  
  - 孩子兄弟表示法：又称二叉树表示法，每个结点除了数据域外，还包含第一个孩子和右邻兄弟。

- 树、森林与二叉树的转换
  
  - 树转换为二叉树的规则：
    
    - （1）顺序连接同一结点的兄弟结点； 
    
    - （2）保留每个结点到其第一个孩子结点的连接作为该结点的左孩子结点，删除这个结点到其他孩子结点的连接； 
    
    - （3）以树的根结点为中心，顺时针旋转一定角度，使得结构层次分明。
  
  - 森林转换为二叉树的规则：
    
    - 将森林中的每棵树转换成相应的二叉树
    
    - 每棵树的根可视为兄弟关系，再每棵树的根之间加一根线

- 树的遍历
  
  - 先序（根）遍历：访问树的根结点；从左到右，依次先序遍历根的每棵子树。
  
  - 后序（根）遍历：从左到右，依次后序遍历根的每棵子树；访问树的根结点。
  
  - 层次遍历：若树不空，则自上而下，自左至右访问树中的每一个结点。

- 森林的遍历
  
  - 先序遍历：访问森林第一棵树的根结点；先序遍历第一棵树中根结点的子树树林；先序遍历除去第一棵树后剩余的树构成的森林。
  
  - 中序遍历：中序遍历第一棵树中根结点的子树树林；访问森林中第一棵树的根结点；中序遍历除去第一棵树后剩余的树构成的森林。
  
  - 后序遍历：中序遍历第一棵树中根结点的子树树林；中序遍历除去第一棵树后剩余的树构成的森林；访问森林中第一棵树的根结点。

- | 树       | 森林   | 二叉树  |
  | ------- | ---- | ---- |
  | 先序（根）遍历 | 先序遍历 | 先序遍历 |
  | 后序（根）遍历 | 中序遍历 | 中序遍历 |
  |         | 后序遍历 | 后序遍历 |

## 5.5哈夫曼树和哈夫曼编码（Huffman）

- 定义：给定N个权值作为叶子结点，构造一棵二叉树，若该树的带权路径长度（WPL)达到最小，称这样的树为哈夫曼树，也称最优树。

- 结点的带权路径长度：从树的根到任意结点的路径长度（经过的边数）与该结点上权值的乘积

- 树的带权路径长度：树中所有叶子结点的带权路径长度之和

- 哈夫曼树的构造
  
  - 根据n个给定的权值(W1,W2,..., Wn)构成n棵二叉树的森林F=(T1, T2,.., Tn),其中Ti只有一个带权为Wi;的根结点
  
  - 在F中选取两棵根结点的权值最小的树作为左右子树,构造一棵新的二叉树,且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
  
  - 在F中删除这两棵树,同时将新得到的二叉树加入森林中。
  
  - 重复(2)和(3),直到森林中只有一棵树为止,这棵树即为哈夫曼树。
  
  - ![](https://img-blog.csdnimg.cn/5567786a0809492e9d6d4dd9c5b6de1b.png)

- 总结：
  
  - 在哈夫曼算法中,初始时有n棵二叉树,要经过n-1次合并最终形成哈夫曼树。
  
  - 经过n-1次合并产生n-1个新结点,且这n-1个新结点都是具有两个孩子的分支结点。
  
  - 哈夫曼树中共有n+n-1 =2n-1个结点,且其所有的分支结点的度均不为1。

- 哈夫曼编码方法
  
  - 统计字符集中每个字符在电文中出现的平均概率(概率越大,要求编码越短)
  
  - 利用哈夫曼树的特点:权越大的叶子离根越近;将每个字符的概率值作为权值,构造哈夫曼树。则概率越大的结点,路径越短。
  
  - 在哈夫曼树的每个分支上标上0或1。结点的左分支标0,右分支标1，把从根到每个叶子的路径上的标号连接起来,作为该叶子代表的字符的编码。
  
  - ![](https://img-blog.csdnimg.cn/970bbd5013904b12981b3aa9049bd289.png)

- 哈夫曼编码（Code）
  
  ```cpp
  //HT为哈夫曼树，HC为存储结点哈夫曼编码的二维动态数组，n为结点的个数
  void HuffmanCoding(HuffmanTree HT, HuffmanCode *HC,int n){
      *HC = (HuffmanCode) malloc((n+1) * sizeof(char *));
      char *cd = (char *)malloc(n*sizeof(char)); //存放结点哈夫曼编码的字符串数组
      cd[n-1] = '\0';//字符串结束符
  
      for(int i=1; i<=n; i++){
          //从叶子结点出发，得到的哈夫曼编码是逆序的，需要在字符串数组中逆序存放
          int start = n-1;
          //当前结点在数组中的位置
          int c = i;
          //当前结点的父结点在数组中的位置
          int j = HT[i].parent;
          // 一直寻找到根结点
          while(j != 0){
              // 如果该结点是父结点的左孩子则对应路径编码为0，否则为右孩子编码为1
              if(HT[j].left == c)
                  cd[--start] = '0';
              else
                  cd[--start] = '1';
              //以父结点为孩子结点，继续朝树根的方向遍历
              c = j;
              j = HT[j].parent;
          }
          //跳出循环后，cd数组中从下标 start 开始，存放的就是该结点的哈夫曼编码
          (*HC)[i] = (char *)malloc((n-start)*sizeof(char));
          strcpy((*HC)[i], &cd[start]);
      }
      //使用malloc申请的cd动态数组需要手动释放
      free(cd);
  }
  ```

# 第六章 图

## 6.1 图的基本概念

- 图的定义：图由顶点集V和边集E组成，记为G=（V，E），其中V表示图G中顶点的有限非空集合，E表示G中顶点之间的关系边集，|V|表示G中顶点的个数也称G的阶。**（注意线性表可以是空表，树可以是空树，但图不能是空图）**

- 图的一些基本概念和术语
  
  - 若E是有向边的有限集合，则........ （由于在离散数学中已经定义的足够详细，这里就不在赘述了）
  
  - 若E是无向边的有限集合，则
  
  - 简单图：不存在重边，环。
  
  - 多重图：若G中某两点之间的边数多于一条，有允许顶点通过一条边和自己相关。
  
  - 完全图：对于无向图而言，在图中任意两个顶点之间都存在边。对于有向图而言，对于途中任意两个顶点之间都存在方向相反的的两条弧。假设有n个顶点，完全无向图有$n(n-1) \over 2$ 条边，完全有向图有$n(n-1)$ 条边。
  
  - 连通：无向图中，若从顶点v到顶点w有路径存在，则二者连通。
  
  - 强连通：在有向图中，顶点v走到顶点w，顶点w也能走到顶点v，则二者强连通。
  
  - 连通图：任意两个顶点都是连通的。（针对于无向图）至少有n-1条边
  
  - 强连通图：任意两个顶点都是强连通的。（针对于有向图）至少有n条边
  
  - 连通分量：无向图G的极大连通子图。极大就是再增加一个顶点就不满足连通图了。
  
  - 强连通分量：有向图G的极大强连通子图。
  
  - 生成树：连通图的生成树是包含所有顶点的极小连通子图，有 $n-1$ 条边（n为顶点数），如果砍去一条边就会变成非连通图，如果加上一条边就会变成回路。
  
  - 生成森林：在非连通图中，连通分量的生成树构成非连通图的的生成森林。
  
  - 简单路径：顶点不重复的路径。
  
  - 简单回路：顶点不重复的回路。

## 6.2 图的存储结构

- 邻接矩阵法
  
  - ![](https://img-blog.csdnimg.cn/20210315132337230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjAxNTMzMw==,size_16,color_FFFFFF,t_70)
  
  - 特点：
    
    - 无向图的邻接矩阵对称，可压缩存储；有n个顶点的无向图需存储空间为 $n(n+1) \over 2$
    
    - 有向图邻接矩阵不一定对称；有n个顶点的有向图需存储空间为n²；
    
    - 无向图中顶点Vi的度TD(Vi)是邻接矩阵A中第i行元素之和；
    
    - 有向图中， 顶点Vi的出度是A中第i行元素之和； 顶点Vi的入度是A中第i列元素之和
    
    - 很容易确定图中任意两个顶点之间是否有边相邻。但是要确定图中有多少边必须按行按列对每个元素进行检测，时间开销大。
    
    - 稠密图适合使用邻居矩阵

- 邻接表
  
  - ![](https://img-blog.csdnimg.cn/20210315132706547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjAxNTMzMw==,size_16,color_FFFFFF,t_70)
  
  - 特点：
    
    - 无向图中顶点Vi的度为第i个单链表中的结点数；
    
    - 有向图中 顶点Vi的出度为第i个单链表中的结点个数；顶点Vi的入度为整个单链表中邻接点域值是i的结点个数；
    
    - 逆邻接表：有向图中对每个结点建立以Vi为头的弧的单链表；
    
    - 若G为无向图，则所需的存储空间为 O(|V|+2|E|),若G为有向图，则所需的存储空间为 O(|V|+|E|)。
    
    - 给定一顶点，很容易求它的所有邻边
    
    - 对于有向图的邻接表，求一个顶点的出度只需要计算其邻接表中的结点个数，但求入度则要遍历整个邻接表
    
    - 图的邻接表表示不唯一
    
    - 稀疏图适合邻接表

- 十字链表
  
  - ![](https://img-blog.csdnimg.cn/cfd94ffbe11e47139ae7b6ca821a5220.png)
  
  - ```cpp
    //顶点结构
    
    typedef string InfoType ;
    typedef string VertexType;
    
    typedef struct VexNode{
        VertexType data; //顶点的数据域
        ArcBox *firstIn; //指向该顶点的第一条入弧
        ArcBox *firstOut; //指向该顶点的第一条出弧
    }VexNode;
    ```
  
  - ```cpp
    //弧结构
    
    typedef struct ArcBox{
        int tailVex; //该弧的尾顶点的位置
        int headVex; //该弧的头顶点的位置
        struct ArcBox * hLink; //弧头相同的弧的链域
        static ArcBox * tLink; //弧尾相同的弧的链域
        InfoType info; //弧的相关信息
    }ArcBox;
    ```
  
  - 弧结点中有5个域：其中尾域（tailvex）和头域（headvex）分别指示弧尾和弧头这两个顶点在图中的位置，链域hlink指向弧头相同的下一条弧，而链域tlink指向弧尾相同的下一条弧，info域指向该弧的相关信息。弧头相同的弧在同一链表上，弧尾相同的弧也在同一链表上。
  
  - 它们的头结点即为顶点结点，它由3个域组成：其中data域存储和顶点相关的信息，如顶点的名称等；firstIn和firstOut为两个链域，分别指向以该顶点为弧头或弧尾的第一条弧结点
  
  - 个人感觉这部分不是重点，欲了解更多,[click here](![]([图的存储结构-十字链表_老攀呀的博客-CSDN博客](https://blog.csdn.net/QQ657205470/article/details/127361701))

- 邻接多重表(个人觉得不是重点，具体参考[click here]([【数据结构】邻接多重表_数据结构邻接多重表-CSDN博客](https://blog.csdn.net/bible_reader/article/details/71250117?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169984384416800185811969%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169984384416800185811969&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-71250117-null-null.142^v96^pc_search_result_base3&utm_term=%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E7%90%86%E8%A7%A3&spm=1018.2226.3001.4187)))
  
  - 顶点结构如下所示：其中data用来记录顶点的信息，firstEdge用来表示依附于该顶点的第一条边。
  
  ![](https://img-blog.csdn.net/20170506114658900)
  
  - 边结点结构如下所示：其中mark表示标志位，用于标记该边是否已经被访问过；iVex和jVex表示该边的两个顶点在顶点数组adjmultiList[num]中的位置；iLink和jLink分别表示指向依附于顶点iVex和jVex下一条边的指针。

![](https://img-blog.csdn.net/20170506114709808)

![](https://img-blog.csdn.net/20170506114715042)

![](https://img-blog.csdn.net/20170506114726448)

如上图所示，结点A-D 之间的边，在邻接多重表中只需要一个边结点既可以表示。另外，在该结构中，每个边结点被链入了两个不同的链表。其中A-D之间的边被链入了红色和绿色标记的链表中。如果需要访问一条边，则可以从该边的两个顶点结点中的任何一个出发，遍历依附于该顶点的边构成的链表即可。如果需要删除一条边，则只需要删除一个边结点，但是需要修改这条边依附的两个顶点所对应的链表。另外，需要注意的是，在无向图中，边结点中的iVex和jVex链域与该边所依附的顶点无关，即iVex=0，jVex=3和iVex=3，jVex=0这都表示同一条边A-D，因此这给链表的指针修改带来一定的麻烦。

## 6.3 图的遍历

- 广度优先搜索（BFS）
  
  - ```cpp
    void bfs(int v,int visit[10])//广度遍历
    {
        visit[v]=1;//标记起始节点
        jd* w;
        queue<int> q;//声明对列
        q.push(v);//起始结点入队 
    
        while(!q.empty())
        {
            v=q.front();//取队头结点
            cout<<v;
            q.pop();//删除(更新)队头元素 
            w=m[v].firstnode;//访问v结点第一个孩子结点
    
            while(w!=NULL)//遍历与某一个元素所有有关系的结点 
            {
                if(!visit[w->id])//若此结点未被遍历过则入队 
                {
                    q.push(w->id);//w->id结点入队
                    visit[w->id]=1;//标记w->id结点
                }
                w=w->next;//访问w的兄弟结点
            }
        }
    } 
    ```
  
  - 性能分析
    
    - 时间复杂度：O(|V|+|E|)
    
    - 空间复杂度：O(|V|),（最坏情况）
  
  - 可以解决最短路问题
  
  - 广度优先生成树：在BFS中，我们可以得到一棵遍历树，即为~。对于邻接矩阵而言，树唯一；对于邻接表而言，树不唯一。

- 深度优先搜索（DFS）
  
  - ```cpp
    void dfs(int v,int visit[10])//深度遍历 
    {
        visit[v]=1;//标记访问过的位置
        jd* w;
        w=m[v].firstnode;//访问v结点的第一个孩子节点
        cout<<v;
    
        while(w!=NULL)//解决某结点分叉 
        {
            if(!visit[w->id])//如果w->id未访问过继续递归进入下一层
                dfs(w->id,visit);
            w=w->next;//如果访问过就访问w->id的兄弟节点
        }
    }
    ```
  
  - 时间复杂度：O(|V|+|E|)

## 6.4 图的应用

- 最小生成树

- 最短路径
  
  - Dijkstra
  
  - Floyd

- 拓扑排序

- 关键路径

##### 由于时间紧迫，暂且只是把知识点过了一遍，来不仅整理成笔记，暂且先搁置吧，hh。&gt;__&lt;

# 第七章 查找、

## 7.1 查找的基本概念

- 定义：在数据集合中寻找满足某种条件的数据元素的过程。

- 查找表：查找表是由同一类型的数据元素（或记录）构成的集合。由于”集合“中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵便的数据结构，可以用其他的数据结构来实现。

- 静态查找表：查找后不会对表进行任何修改

- 动态查找表：查找后会对表进行修改

- 关键字：关键字是数据元素（或记录）中某个数据项的值，用它可以标识一个数据元素（或记录）；若此关键字可以唯一的标识一个记录，则称此关键字为主关键字（对不同的记录，其主关键字均不同）。反之，称用以识别若干记录的关键字为次关键字。当数据元素只有一个数据项时，其关键字即为该数据元素的值。

- 平均查找长度ASL（查找算法的评价指标）：为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的平均查找长度（Average Search Length）

## 7.2 顺序查找&折半查找&分块查找

- 顺序查找：从表的一端开始，依次将记录的关键字和给定的值进行比较，若某个记录的关键字和给定值相等，则查找成功；反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失败。
  
  - 优点：对数据元素的存储没有要求，对表中元素的顺序也没有要求。
  
  - 缺点：当元素数量多时，平均查找长度大，效率低。
  
  - ![](https://img-blog.csdnimg.cn/dfe504dae1a14a88931d33b98ae7358e.png)
  
  - ![](https://img-blog.csdnimg.cn/dfb6e7a19e824bccb6b2fb8aa0274afa.png)

- 折半查找
  
  - 实现过程：
    
    - 设表长为n、low、high和mid分别指向待查元素所在区间的上界、下界和中点，key为给定的要查找的值
    
    - 初始时，令low=1，high=n，mid=[(low+high)/2]
    
    - 让k与mid指向的记录比较；若key==R[mid].key，查找成功；若key\<R[mid].key，则high=mid-1;若key>R[mid].key，则low=mid+1；若low>high,则返回0代表元素不存在。
  
  - ![](https://img-blog.csdnimg.cn/4b179e024a5d4e40a44e2dc05f5927fb.png)
  
  - 优点：效率比顺序查找高
  
  - 缺点：折半查找只适用于有序表，且限于顺序存储结构（对线性链表是无效的）
  
  - 时间复杂度：$O(log_2n)$ ,比较次数是小于或等于树的深度（log2n）+1.
  
  - 平均查找长度ASL(成功时)：树高h= $log_2(n+1)$![](https://img-blog.csdnimg.cn/3e8c4093427444468196a187c26d84aa.png)

- 分块查找
  
  - 实现过程：
    
    - 将表分成若干子块
    
    - 块内元素元素可以无序，但是块之间有序，第一个块中的最大关键字小于第二个块中的所有记录的关键字，以此类推，再建立一个索引表，索引表中的每个元素含有各块中的第一个元素地址，索引表按关键字有序排列。
  
  - 分块查找的平均查找长度：![](https://img-blog.csdnimg.cn/29f0f2cacb324ed2958a754cacb1401f.png)其中n为元素个数，s为每块元素个数

### 剩下的散列表，Dijksta，Floyd，B树，B+树由于时间紧迫，期末考试在即，就先不写了，之后有时间再补（可能也不会再补了,hh）&gt;__&lt;.

# 第八章 排序

## 8.1排序的基本概念

- ***定义***：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。

- **稳定性**：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的

- **内部排序**：数据元素全部放在内存中的排序。

- **外部排序**：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。

## 8.2 插入排序

- 直接插入排序
  
  - 实现过程：
    
    1. 数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
    
    2. 定义i和j两个变量，i用来遍历未排序序列，j用来遍历已排序的序列，j跟在i下标位置之后，i从头到尾依次扫描未排序序列，将未排序序列当中i下标的数字，与已排好序的序列当中的数字依次进行比较，若未排序序列当中i下标的数字比已排序序列当中j下标的数字小，则将已排序序列当中的数字向后挪动一位，将i下标的数字插入当已排好序的序列中。(如果待插入的元素与有序序列当中的某个元素相等，则将代插入元素插入到相等元素的后面。)
  
  - ```cpp
    //时间复杂度最坏：O(N^2) --逆序
    //时间复杂度最好：O(N) --顺序有序
    void InsertSort(int* a, int n)
    {
        for (int i = 0; i < n-1; i++)
        {
            int end = i;
            int tmp = a[i+1];//需要比较的数据先存起来,因为数据可能被覆盖
            while (end >= 0)
            {
                //如果tmp小于end值,end向右挪动
                if (tmp < a[end])
                {
                    a[end + 1] = a[end];
                    end--;
                }
                //tmp比end大不需要再调整
                else
                {
                    break;
                }
            }
            //在end后插入新数据
            a[end + 1] = tmp;
        }
    }
    ```
  
  - 动图演示：![](https://img-blog.csdnimg.cn/3b98e02eb3f14b6ea6e4c8d7f056c018.gif)
  
  - 静图演示：![](https://img-blog.csdnimg.cn/95df1c30fcf44e4db6a5da6eea5fa087.png)

> ### 总结：
> 
> 1. 元素集合越接近有序，直接插入排序算法的时间效率越高
> 
> 2. 时间复杂度： $O(n^2)$  ，最好情况  $O(n)$
> 
> 3. 空间复杂度： $O(1)$ 
> 
> 4. 稳定性：稳定

- 折半插入排序
  
  - 实现过程：
    
    1. 确定折半插入排序的范围
    
    2. 对其进行类似于二分法界定的方法，不断缩小范围
    
    3. 对数据进行移动，对待排序算法进行插入
  
  - 性能分析：
    
    - 空间复杂度： $O(1)$ 
    
    - 时间复杂度： $O(nlog_2n)$ ,仅和表中元素个数有关
    
    - 稳定性：稳定
  
  - 适用于顺序存储

- 希尔排序（缩小增量排序）
  
  - 实现过程：先对数组的子数组（按照一定的规则划定而成）进行排序，使待排序数组变得相对有序，最后再对整个数组及进行一次排序完成整体的排序。当gap > 1时都是预排序，目的时让数组更接近于有序。当gap==1时，数组已接近有序，这样最后进行直接插入排序，这样代码的效率会很快，这样就达到了优化的效果
  
  - ```cpp
    //第一种写法
    void ShellSort(int* a, int n)
    {
        // 1、gap > 1 预排序
        // 2、gap == 1 直接插入排序
    
        int gap = n;
        while (gap > 1)
        {
            //gap有两种常见的取法,并没有规定哪种取法更优
            //gap = gap / 2;
            gap = gap / 3 + 1;
    
            //gap组数据每一组都进行一次单趟排序
            for (int j = 0; j < gap; j++)
            {   
                //一次单趟排序,类似直接插入排序,不过gap不再只是1
                for (int i = j; i < n - gap; i += gap)
                {
                    int end = i;
                    int tmp = a[end + gap];
                    while (end >= 0)
                    {
                        if (tmp < a[end])
                        {
                            a[end + gap] = a[end];
                            end-=gap;
                        }
                        else
                        {
                            break;
                        }
                    }
                    a[end + gap] = tmp;
                }
            }
        }
    }
    
    //第二种写法
    //省略一层循环
    void ShellSort(int* a, int n)
    {
        // 1、gap > 1 预排序
        // 2、gap == 1 直接插入排序
    
        int gap = n;
        while (gap > 1)
        {
            //gap有两种常见的取法,并没有规定哪种取法更优
            //gap = gap / 2;
            gap = gap / 3 + 1;
    
            //省略一层循环,但效果其实一样,第一种是每个gap组全都排序完再排序下一组,而这是依次对每个gap组进行一次排序，效果是一样的
            for (int i = 0; i < n - gap; i ++)
            {
                int end = i;
                int tmp = a[end + gap];
                while (end >= 0)
                {
                    if (tmp < a[end])
                    {
                        a[end + gap] = a[end];
                        end -= gap;
                    }
                    else
                    {
                        break;
                    }
                }
                a[end + gap] = tmp;
            }
        }
    }
    ```
  
  - 图片演示：![](https://img-blog.csdnimg.cn/bc61e1274dd64cd9a8bc637ba621e7b6.png)
    
    shell方法的思路理解
    
    ![](https://img-blog.csdnimg.cn/b585262580cc4dd087b09788f3b6e5b3.png)

> ### 总结
> 
> 1. 时间复杂度：$O(n^2)$
> 
> 2. 空间复杂度： $O(1)$
> 
> 3. 稳定性：不稳定
> 
> 4. 适用于顺序存储

## 8.3交换排序

- 冒泡排序：由于比较简单，大一就学过了，这里不再赘述了。hh    
  
  - ```cpp
    void BubbleSort(int* a, int n)
    {
        for(int i=0;i<n;i++)
        {
            int flag = 1;
            for(int j=0;j<n-1-i;j++)
            {
                if(a[j]>a[j+1])
                {
                    SWAP(&a[j],&a[j+1]);
                    flag = 0;
                }
            }
            if(flag) break;
        }
    }
    ```
  
  - > ### 总结
    > 
    > 1. 时间复杂度： $O(n^2)$
    > 
    > 2. 空间复杂度：$O(1)$
    > 
    > 3. 稳定性：稳定

- 快速排序：由于在AcWing上已经刷过无数遍了，这里也不赘述了，hh
  
  - ```cpp
    #include<iostream>
    
    using namespace std;
    
    const int N=1e+6;
    void quick_sort(int p[],int x,int y)
    {
        if(x>=y) return;
        int k=(x+y)/2;
        int z=p[k],i=x-1,j=y+1;
        while(i<j)
        {
            do i++;while(p[i]<z);
            do j--;while(p[j]>z);
            if(i<j) 
            {
                int temp=p[i];
                p[i]=p[j];
                p[j]=temp;
            }
        }
        quick_sort(p,x,j),quick_sort(p,j+1,y);
    }
    int main()
    {
        int n,q[N];
        scanf("%d",&n);
        for(int i=0;i<n;i++)scanf("%d",&q[i]);
        quick_sort(q,0,n-1);
        for(int i=0;i<n;i++)printf("%d ",q[i]);
        return 0;
    }
    
    作者：snowstorm
    链接：https://www.acwing.com/activity/content/code/content/5754712/
    来源：AcWing
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
    ```
    
    > ### 总结：
    > 
    > 1. 时间复杂度：最好，平均情况 $O(nlong_2n)$  ,最坏情况 $O(n^2)$ （当初始排序表基本有序或者基本逆序情况下）
    > 
    > 2. 空间复杂度：O(1)
    > 
    > 3. 稳定性：不稳定
    > 
    > 4. 适用于顺序存储
    > 
    > 5. 快速排序被认为是目前基于比较的内部排序的最好方法

## 8.4选择排序

- 简单选择排序
  
  - 不说了，直接看图--->![](https://img-blog.csdnimg.cn/fec4b23e6127455baf4b6dcc057c5073.png)
    
    ![](https://img-blog.csdnimg.cn/84a524f63b704673afd4d1f34972a20d.gif)
  
  - ```cpp
    void SelectSort(int* a, int n)
    {
        int begin = 0;
        int end = n - 1;
        while (begin < end)
        {
            int maxi = begin;
            int mini = begin;
            for (int i = begin; i <= end; i++)
            {
                if (a[i] > a[maxi])
                    maxi = i;
                if (a[i] < a[mini])
                    mini = i;
            }
            Swap(&a[begin], &a[mini]);
            //关键:如果最小值和begin交换完而此时最大值就在begin位置,
            //最大值被交换到了原来的最小值位置,这种情况下需要重新确定最大值位置。
            if (begin == maxi)
                maxi = mini;
            Swap(&a[end], &a[maxi]);
            begin++;
            end--;
        }
    }
    ```
  
  - > ### 总结
    > 
    > 1. 直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用  
    > 
    > 2. 时间复杂度：$O(n^2)$
    > 
    > 3. 空间复杂度：$O(1)$
    > 
    > 4. 稳定性：不稳定

- 堆排序
  
  > ### 下面的是我tm抄csdn上的一位博主的，我tm自己也没怎么看明白，hh
  > 
  > ❓❓❓那么这里有一个问题，当我们要将一组数据按照从小到大的顺序进行排序，那么我们采用大根堆好，还是小根堆好？？
  > 
  > ❌这里肯定有很多同学认为使用小根堆好，每次将堆顶元素弹出，放在新的数组中，这样将数据弹完，数据也就有序了，这确实是一种方法，但是这样写这个方法的空间复杂度，会非常大。
  > ✅这里我们使用大根堆排序升序(从小到大)的数据，当我们找到数据中的最大值的时候，他一定是在大根堆的堆顶，我们将堆顶元素与最后一个元素交换位置，将堆顶元素放在数组的最后一位。放好之后最后一位不进入接下来的比较，交换。
  > 使用小根堆排序降序(从大到小)的数据，当我们找到最小值的时候，他一定在堆顶，做法与上述相同
  > 
  > ❓❓❓很多同学在没有了解堆的概念的话，在看这个代码当中的堆排序（heapSort）方法时，会有这样一个疑问，为什么在将父节点和最后一个结点交换之后，没有对end减一，而是直接向下调整了，这样不会将刚交换的最大值，有放在0下标位置吗？？
  > 
  >  ❗❗❗这里其实是你多虑了，当我们在实现堆排序（heapSort）时，定义的end不仅用来记录最后一个结点的位置，用来将end下标的结点和0下标的结点进行交换，也可以用来记录未排序数列的长度，传给shifDown（向下调整）方法。例如：原数组长为10，最后一个结点的下标为9，将0下标与9下标的值，进行交换，然后调用shifDown方法，传给这个方法的参数为，数组本身，0下标，可以认为是，未排序数列的长度，或者是结束位置是9下标，这样就将第10个已经交换了位置的元素，没有放入向下调整的方法中。
  
  - 定义：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是通过堆来进行选择数据。**需要注意的是排升序要建大堆，排降序建小堆。**
  
  - ```cpp
    void AdjustDown(int* a, int n,int parent)
    {
        int child = 2 * parent + 1;
        while (child < n)
        {
            if (child + 1 < n && a[child + 1] > a[child])
                child++;
            if (a[parent] < a[child])
            {
                Swap(&a[parent], &a[child]);
                parent = child;
                child = 2 * parent + 1;
            }
            else
            {
                break;
            }
        }
    
    }
    
    void HeapSort(int* a, int n)
    {
        for (int i = (n - 1 - 1) / 2; i >= 0; i--)
        {
            AdjustDown(a,n,i);
        }
        int end = n - 1;
        while (end > 0)
        {
            Swap(&a[0], &a[end]);
            AdjustDown(a, end,0);
            end--;
        }
    }
    ```
    
    > ### 总结：
    > 
    > 1. 堆排序使用堆来选数，效率就高了很多。  
    > 
    > 2. 时间复杂度：$O(nlog_2n)$
    >    
    >    1. 空间复杂度：$O(1)$ 
    > 
    > 3. 稳定性：不稳定

## 8.5 归并排序

- 由于在AcWing上已经刷了很多遍了，这里就不在赘述了
  
  ```cpp
  void _MergeSort(int* a, int left,int right,int* tmp)
  {
      if (left == right)//可以不写left<=right,因为这里不会像快排一样出现不存在的区间
          return;
  
      int mid = left+(right-left) / 2;
      _MergeSort(a, left, mid, tmp);
      _MergeSort(a, mid + 1, right, tmp);
      //归并,选小的尾插
      int begin1 = left, end1 = mid;
      int begin2 = mid + 1, end2 = right;
      int i = left;
      while (begin1 <= end1 && begin2<=end2)
      {
          if (a[begin1] <= a[begin2])//左数组处理相等数据保证稳定性
          {
              tmp[i++] = a[begin1++];
          }
          else
          {
              tmp[i++] = a[begin2++];
          }
      }
      //一组数据归并完，剩余数据依次插入
      while (begin1 <= end1)
      {
          tmp[i++] = a[begin1++];
      }
      while (begin2 <= end2)
      {
          tmp[i++] = a[begin2++];
      }
      //拷贝到原数组
      memcpy(a+left, tmp+left, sizeof(int) * (right-left+1));
  }
  
  void MergeSort(int*a,int n)
  {
      int* tmp = (int*)malloc(sizeof(int) * n);
      if(tmp == NULL)
      {
          perror("malloc fail");
          exit(-1);
      }
      _MergeSort(a, 0, n - 1, tmp);
      free(tmp);
  }
  ```
  
  > ### 总结：
  > 
  > 1. 归并的缺点在于需要O(N)的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题。  
  > 
  > 2. 时间复杂度：$O(nlog_2n)$
  > 
  > 3. 空间复杂度：$O(n)$ 
  > 
  > 4. 稳定性：稳定

## 8.6 基数排序（本人也不是很懂，估计考试也不怎么考，就随便写写,hh)

- **实现步骤**
  
  1. 确定数组中的最大元素有几位（MAX）（确定执行的轮数）
  
  2. 创建0~9个桶（桶的底层是队列），因为所有的数字元素都是由0~9的十个数字组成
  
  3. 依次判断每个元素的个位，十位至MAX位，存入对应的桶中，出队，存入原数组；直至MAX轮结束输出数组

- 静图演示：![](https://img-blog.csdnimg.cn/6051d515d860423e8d880646c6bdfd71.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc-mAkOaipuWwkeW5tA==,size_20,color_FFFFFF,t_70,g_se,x_16)

- 动图演示![](https://img-blog.csdnimg.cn/61741d6de371470cabcc74b4a726b053.gif%23pic_center)

- ```cpp
  #include <stdio.h>
  #include <string.h>
  
  const int MAXN = 100005;          // (1) 
  const int MAXT = 8;               // (2) 
  const int BASE = 10;              // (3) 
  int PowOfBase[MAXT];              // (4) 
  int RadixBucket[BASE][MAXN];      // (5) 
  int RadixBucketTop[BASE];         // (6) 
  ```

```cpp
void InitPowOfBase() {
 int i;
 PowOfBase[0] = 1;
 for(i = 1; i < MAXT; ++i) {
 PowOfBase[i] = PowOfBase[i-1] * BASE; // (7)
 }
 }

void Input(int n, int *a) {
 int i;
 for(i = 0; i < n; ++i) {
 scanf("%d", &a[i]);
 }
 }

void Output(int n, int *a) {
 int i; 
for(i = 0; i < n; ++i) {
 if(i)
 printf(" ");
 printf("%d", a[i]);
 }
 puts("");
 }

int getRadix(int value, int pos) {
 return value / PowOfBase[pos] % BASE; // (8)
 }

void RadixSort(int n, int *a) { // (9)
 int i, j, top = 0, pos = 0;
 while (pos < MAXT) { // (10)
 memset(RadixBucketTop, 0, sizeof(RadixBucketTop)); // (11)
 for(i = 0; i < n; ++i) {
 int rdx = getRadix(a[i], pos);
 RadixBucket[ rdx ][ RadixBucketTop[rdx]++ ] = a[i]; // (12)
 }
 top = 0;
 for(i = 0; i < BASE; ++i) {
 for(j = 0; j < RadixBucketTop[i]; ++j) {
 a[top++] = RadixBucket[i][j]; // (13)
 }
 }
 ++pos; 
}
 }

int a[MAXN];

int main() {
 int n;
 InitPowOfBase();
 while(scanf("%d", &n) != EOF) {
 Input(n, a);
 RadixSort(n, a);
 Output(n, a);
 }
 return 0;
 } 
/*
 15
 3221 1 10 9680 577 9420 7 5622 4793 2030 3138 82 2599 743 4127
 *
```

> (1) 排序数组的元素最大个数；
> (2) 排序元素的数字的最大位数；
> (3) 排序元素的进制，这里为 十进制；
> 
> (4) `PowOfBase[i]`代表`BASE`的`i`次幂；
> (5) `RadixBucket[i][]`代表第 `i` 个队列；
> (6) `RadixBucketTop[i]`代表第 `i` 个队列的尾指针；
> (7) 初始化`BASE`的i次幂；
> (8) 计算`value`的`pos`位的值；
> (9) `void RadixSort(int n, int *a)`为 基数排序 的实现，代表对`a[]`数组进行升序排序；
> (10) 进行`MAXT`轮迭代；
> (11) 迭代前清空队列，只需要将队列尾指针置零即可；
> (12) 入队操作；
> (13) 将队列中的元素按顺序塞回原数组；

> ### 总结
> 
> 1. 时间复杂度：O(d(n+r)) d表达趟数，一趟收集需要O(r) ，一趟分配需要O(n)
> 
> 2. 空间复杂度： O(r)
> 
> 3. 稳定性：稳定
> 
> 4. 与序列的初始状态无关

## 8.7各种内部排序的比较

- ![](https://img-blog.csdnimg.cn/0b365b0815be4d1991d48ac32576f634.png)

- 当n较小时，可选择直接插入排序或者简单选择排序

- 当记录本身信息量较大，用简单选择排序

- 若序列的初始状态已按关键字基本有序，则选用直接插入排序或者冒泡排序

- 快速排序被认为是目前基于比较的内部排序方法中最好的方法，待排序的序列关键字随机分布时，快排最快

- 若n较大，采用快排，归并，堆排序的时间复杂度为$O(nlog_2n)$ ,其中归并是稳定算法

- 若n较大，记录的关键字位数较少且可以分解时，基数排序较好

## 8.8 外部排序

- **外部排序的基本概念** ：外存中的数据读入内存→在内存中排序→数据写入外存

- **外部排序的思想**：
  
  1. 数据初始状态![](https://img-blog.csdnimg.cn/fb60815e51ad406fa96a80ad827847e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  2- 将（36、8、26）（42、9、48）分别存入输入缓冲区1、输入缓冲区2 ![](https://img-blog.csdnimg.cn/b9f282cd18524b46a1609e8a2bfe05c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  3- 将输入缓冲区![](https://img-blog.csdnimg.cn/6fad1f6bdc5a4c8097aa3e2657f7fa62.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  4- 将输入缓冲区1和输入缓冲区2的数据通过输出缓冲区逐一写入外存，形成一个有序归并段![](https://img-blog.csdnimg.cn/2ef4a5a1ff73456da37eda0e863b4258.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  5- 将（1、37、25）（45、27、28）分别存入输入缓冲区1、输入缓冲区2![](https://img-blog.csdnimg.cn/b4b6d4c0be484302ae4217a4c687d1a2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  6- 将输入缓冲区1和输入缓冲区2的数据进行递增排序![](https://img-blog.csdnimg.cn/21090c7c92904c30afcf68f94295c4bb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  7- 将输入缓冲区1和输入缓冲区2的数据通过输出缓冲区逐一写入外存，形成一个有序归并段 ![](https://img-blog.csdnimg.cn/3e1d9b549f63450faa4f2f9a6a4cec29.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  8- 对剩余12块内存依次进行上述操作，总共需要进行16次读操作和16次写操作，得到初始归并段 ![](https://img-blog.csdnimg.cn/3ecc414b5b824b34a181bacc42d70ee5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  9- 第一次归并：读入归并段1和归并段2中的第一块磁盘（相对最小），进行排序 ![](https://img-blog.csdnimg.cn/b2f0bc600f5f4c6b84607887401587a3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  10- 依次找出这两个输入缓冲区中最元素，并将其移动到输出缓冲区中，当输出缓冲区满，则写入外存（1、8、9） ![](https://img-blog.csdnimg.cn/99ee841270b54d7788264256a0f1b851.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  11- 继续找出这剩余元素中的最小元素，直到某一个缓冲区中空，则读入其所属归并段的后一个内存块的数据，并继续进行上述操作。直到两个缓冲区都空，且归并段1和归并段2中的元素全部读入内存，此时归并段1和归并段2就得到了一个有序的递增序列,输入缓冲区1空![](https://img-blog.csdnimg.cn/f260376ffd784583a505675271b3a4ca.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  12- 输入归并段1的第二块内存![](https://img-blog.csdnimg.cn/d44b8e35563d448198a17308af438d85.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  13- 排序完成，归并段1和归并段2递增有序![](https://img-blog.csdnimg.cn/cfa296373aa44a3eb732caa184f96dbb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  14- 对剩余的六个归并段进行上述操作，八个归并段→四个归并段![](https://img-blog.csdnimg.cn/bf234ec9f4ca4f038e8b61fd84628756.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  15- 第二次归并：继续采用此方法依次取出归并段1和归并段2（归并段1为八个归并段时的归并段1和归并段2，归并段2为八个归并段时的归并段3和归并段4）的各个块进行排序操作（步骤9、10、11）→四个归并段→两个归并段,原归并段1、2排序形成归并段1![](https://img-blog.csdnimg.cn/5297c6b268af41dc9d741b059a03e76b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  16- 原归并段3、4排序形成归并段2 ![](https://img-blog.csdnimg.cn/afc4e60dfd0e4192bb8cccd4789492f4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  17- 第三次归并：继续排序归并段1、2，形成最后的有序递增序列![](https://img-blog.csdnimg.cn/01d3d620ae3c4d1b9a5e047919deae31.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)

- **外部排序的开销：** 总时间开销 = 内部排序所需时间 + 内部归并所需时间 + 外部读写所需时间

- **归并排序优化：**
  
  1. 增大归并路数k
  
  2. 减少初始归并段个数r

- **败者树**
  
  - **背景**：为了使内部归并不受k（归并路数）的增大影响
  
  - **基本思想**：k个叶子结点分别存放k个归并段，在归并过程中，内部结点用来记忆左右子树中比较的失败者（大者为失败者），    而让胜者往上继续比较，一直到根结点。
  
  - **实现过程**：
    
    1. 将每个归并段的第一个元素作为叶子结点加入败者树中![](https://img-blog.csdnimg.cn/91cfd388e9764c438cd426395c868bc3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
    
    2. 从左至右、从上往下的更新分支节点的信息：判断其左右子树的大小，除了根节点（最上面那个结点）记录冠军来自哪个归并段外，其余各分支节点记录的是失败者来自哪个归并段 ![](https://img-blog.csdnimg.cn/3b876d682c5b424e959671bafd66272b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
    
    3. 取出最小的元素1后，从其所属的归并段中取出下一个元素6，依次与从叶子结点到根节点的各个结点所记录的败者信息进行对比 ![](https://img-blog.csdnimg.cn/85d5cc24e6404d9ab01c906e2eafea6b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
  
  - 性能分析：k路归并的败者树深度为$O(log_2k)$  

## 8.9置换选择排序

- **算法思想**
  
  1. 将待排序文件FI输入w个数据到内存工作区WA中
  
  2. 选择WA中关键字最小的数据，输出到FO中，并且用MIN记录该最小关键字
  
  3. 若FI不空，则从FI中继续输入文件到WA
  
  4.  从WA中选出比MIN更大的关键字的数据，输出并更新此最小关键字作为新MIN
  
  5. 重复②~④直到WA中的每个关键字都＞MIN为止，由此得到一个新的归并段
  
  6. 重复②~⑤，直到WA空，得到全部初始归并段

- **模拟过程**
  
  1. 初始状态![](https://img-blog.csdnimg.cn/42329fe0b10f4890b566888947c03402.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5rGf5Y2X5rGf5Y2X5rGf5Y2X5Li2,size_20,color_FFFFFF,t_70,g_se,x_16)
     
     2.4、6、9依次加入内存工作区中，（4、6、9）选择最小的元素4，输出4并更改MIN = 4
     
     3.加入7，（7、6、9）选择最小元素6 > MIN = 4，输出6并更改MIN = 6
     
     4.加入13，（7、13、9）选择最小元素7 > MIN = 6，输出7并更改MIN = 7
     
     5.加入11，（11、13、9）选择最小元素9 > MIN = 7，输出9并更改MIN = 9
     
     6.加入16，（11、13、16）选择最小元素11 > MIN = 9，输出11并更改MIN = 11
     
     8.加入14，（14、13、16）选择最小元素13 > MIN = 11，输出13并更改MIN = 13
     
     9.加入10，（14、10、16）选择最小元素10 < MIN = 13，标记13为不可输出，选择第二小的元素14 > MIN = 13，输出14并更改MIN = 14
     
     10.加入22，（22、10、16）选择最小元素16  > MIN = 14，输出16并更改MIN = 16
     
     11.加入30，（22、10、30）选择最小元素22 > MIN = 16，输出并更改MIN = 22
     
     12.加入2，（2、10、30）选择最小元素2 < MIN = 22，标记2为不可输出，选择第三小的元素30 > MIN = 22，输出30并更改MIN = 30
     
     13.加入3，（2、10、3）选择最小元素3 < MIN = 30，标记2为不可输出，此时，输出缓冲区中的三个元素都是不可输出元素，则第一个归并区到上一个输出元素为止（4、6、7、9、11、13、14、16、22、30）
     
     归并段2： 
     
     14.（2、10、3）选择最小元素2，输出2并更改MIN = 2
     
     15.加入19，（19、10、3）选择最小元素3 > MIN = 2，输出3并更改MIN = 3
     
     16.加入20，（19、10、20）选择最小元素10 > MIN = 3，输出10并更改MIN = 10
     
     17.加入17，（19、17、20）选择最小元素17 > MIN = 10，输出17并更改MIN = 17
     
     18.加入1，（19、1、20）选择最小元素1 < MIN = 17，标记1为不可输出，选择第二小的元素19 > MIN = 17，输出19并更改MIN = 19
     
     19.加入23，（23、1、20）选择最小元素20 > MIN = 19，输出20并更改MIN = 20
     
     20.加入5，（23、1、5）选择最小元素5 < MIN = 20，标记5为不可输出，选择第三小的元素23 > MIN = 23，输出23并更改MIN = 23
     
     21.加入36，（36、1、5）选择最小元素36 > MIN = 36，输出36并更改MIN = 36
     
     22.加入22，（12、1、5）选择最小元素12 < MIN = 36，标记12为不可输出时，输出缓冲区中的三个元素都是不可输出元素，则第二个归并区到上一个输出元素为止（2、3、10、17、19、20、23、36）
     
     第三个归并段：
     
     23.（12、1、5）选择最小元素1，输出1并更改MIN = 1
     
     24.加入18，（12、18、5）选择最小元素5 > MIN = 1，输出5并更改MIN = 5
     
     25.加入21，（12、18、21）选择最小元素12 > MIN = 5，输出12并更改MIN = 12
     
     26.加入39，此时，待排序文件空，将内存工作区中的剩余数据按序输出，即18、21、39，则第三个归并段为（1、5、12、18、21、39

## 8.10 最佳归并树（md，实在是没有精力整了，随便水水了）

- 性质和构造完全相同于哈弗曼树

- 与哈弗曼树的区别：k叉树，其中k > 2时：需要判断是否能满足构造完全k叉树，若不满足，则需要添加长度为0的“虚段”

- 若（初始归并段数量 - 1） % （k - 1） = 0，则能构成完全k叉树

- 若（初始归并段数量 - 1） % （k - 1）= u ≠ 0，则说明需要添加（k - 1）- u 个虚段才能构成完全二叉树
